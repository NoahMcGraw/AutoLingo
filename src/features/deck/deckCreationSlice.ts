import { createAsyncThunk, createSlice, nanoid } from '@reduxjs/toolkit'
import { RootState } from '../../context/store'
import { LanguageCode } from '../../models/Language.model'
import { capitalizeFirstLetter } from '../../utils'

export interface DeckCreationState {
  formData: {
    name: string
    topics: string[]
    sourceLang: LanguageCode
    targetLang: LanguageCode
  }
}

const initialState: DeckCreationState = {
  formData: {
    name: 'New Deck',
    topics: [],
    sourceLang: LanguageCode.EN,
    targetLang: LanguageCode.ES,
  },
}

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(fetchTranslations(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const generateDeckName = createAsyncThunk(
  'deckCreation/generateDeckName',
  async ({ topics }: { topics: string[] }, { rejectWithValue }) => {
    try {
      let response = 'New Deck' as string
      // TODO: Remove this once the API is ready
      // const autoLingoAPI = new AutoLingoAPI()
      // const generatedName = await autoLingoAPI.generateDeckName()

      function generateDeckName() {
        let generatedName = '' as string
        topics.forEach((topic) => {
          if (topics.length > 1 && topic === topics[topics.length - 1]) {
            generatedName += ' and '
          }
          generatedName += capitalizeFirstLetter(topic)
          if (topics.length > 2 && topic !== topics[topics.length - 1]) {
            generatedName += ', '
          }
        })
        return generatedName.trim()
      }

      const generatedName = generateDeckName()

      if (generatedName.length) {
        response = generatedName
      }
      return response
    } catch (_error) {
      const error = _error as Error
      console.error(error.message)
      rejectWithValue('There was an error contacting the server: ' + error.message)
    }
  }
)

export const deckCreationSlice = createSlice({
  name: 'deckCreation',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setName: (state, action) => {
      const name = action.payload
      state.formData.name = name
    },
    resetName: (state) => {
      state.formData.name = 'New Deck'
    },
    addTopic: (state, action) => {
      const topic = action.payload
      state.formData.topics.push(topic)
    },
    removeTopic: (state, action) => {
      const topic = action.payload
      state.formData.topics = state.formData.topics.filter((t) => t !== topic)
    },
    resetTopics: (state) => {
      state.formData.topics = []
    },
    setSourceLang: (state, action) => {
      const sourceLang = action.payload
      state.formData.sourceLang = sourceLang
    },
    resetSourceLang: (state) => {
      state.formData.sourceLang = LanguageCode.EN
    },
    setTargetLang: (state, action) => {
      const targetLang = action.payload
      state.formData.targetLang = targetLang
    },
    resetTargetLang: (state) => {
      state.formData.targetLang = LanguageCode.ES
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  // NOTICE: The reducers for changing the status of the async thunk are not defined here, but in the statusSlice.ts file
  extraReducers: (builder) => {
    builder.addCase(generateDeckName.fulfilled, (state, action) => {
      if (typeof action.payload !== 'undefined') {
        state.formData.name = action.payload
      }
    })
  },
})

export const {
  setName,
  resetName,
  addTopic,
  removeTopic,
  resetTopics,
  setSourceLang,
  resetSourceLang,
  setTargetLang,
  resetTargetLang,
} = deckCreationSlice.actions

/**
 * Selectors
 */
export const selectFormData = (state: RootState) => state.deckCreation.formData

export const selectName = (state: RootState) => state.deckCreation.formData.name

export const selectTopics = (state: RootState) => state.deckCreation.formData.topics

export const selectSourceLang = (state: RootState) => state.deckCreation.formData.sourceLang

export const selectTargetLang = (state: RootState) => state.deckCreation.formData.targetLang

export default deckCreationSlice.reducer
